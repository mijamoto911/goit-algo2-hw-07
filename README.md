# goit-algo2-hw-07

# LRU Cache для оптимізації доступу до даних

## Опис проекту

Цей проект демонструє реалізацію та використання LRU-кешу (Least Recently Used) для оптимізації доступу до даних у масиві. Програма реалізує обробку двох типів запитів до масиву: обчислення суми елементів у заданому діапазоні та оновлення значень елементів. Продуктивність порівнюється між реалізаціями з використанням LRU-кешу та без нього.

## Принцип роботи LRU-кешу

LRU-кеш є структурою даних, яка зберігає обмежену кількість записів і автоматично видаляє найменш недавно використані елементи, коли досягається ліміт розміру. Ключові особливості:

1. **Обмежений розмір**: Кеш має заданий максимальний розмір.
2. **Політика заміщення**: При досягненні максимального розміру, видаляється найменш недавно використаний елемент.
3. **Доступ до даних**: При кожному доступі до елементу, він помічається як "нещодавно використаний".

## Функціональність

Проект включає наступні основні функції:

### Функції без кешування:

- `range_sum_no_cache(array, L, R)`: Обчислює суму елементів на відрізку від L до R включно.
- `update_no_cache(array, index, value)`: Оновлює значення елемента в масиві за вказаним індексом.

### Функції з кешуванням:

- `range_sum_with_cache(array, L, R, cache)`: Обчислює суму елементів, використовуючи LRU-кеш.
- `update_with_cache(array, index, value, cache)`: Оновлює значення елемента та інвалідує відповідні записи в кеші.

## Переваги використання LRU-кешу

1. **Зменшення обчислювальних витрат**: Повторні запити до того самого діапазону повертаються з кешу, минаючи повторне обчислення.
2. **Підвищена швидкодія**: При частих запитах до одних і тих самих діапазонів, кеш значно прискорює роботу.
3. **Ефективне використання пам'яті**: Зберігаються тільки найбільш затребувані результати.
4. **Автоматичне керування**: Видалення найменш використаних елементів відбувається автоматично.

## Структура проекту

```
.
├── main.py                 # Основний файл з програмою
└── README.md               # Файл з описом проекту
```

## Класи та їх методи

### `LRUCache`

- `__init__(capacity)`: Ініціалізує кеш із заданою ємністю.
- `get(key)`: Отримує значення з кешу за ключем. Повертає None, якщо ключ відсутній.
- `put(key, value)`: Додає або оновлює запис у кеші.
- `invalidate(index)`: Видаляє з кешу всі записи, що включають заданий індекс.

## Приклад використання

```python
# Створення кешу
lru_cache = LRUCache(1000)

# Обчислення суми з використанням кешу
result = range_sum_with_cache(array, 10, 50, lru_cache)

# Оновлення значення з використанням кешу
update_with_cache(array, 25, 100, lru_cache)
```

## Тестування продуктивності

Для демонстрації переваг кешування, програма:

1. Генерує масив розміром до 100,000 елементів.
2. Створює до 50,000 випадкових запитів (80% Range, 20% Update).
3. Виконує запити без використання кешу.
4. Виконує ті ж запити з використанням LRU-кешу.
5. Порівнює час виконання та виводить статистику.

## Результати тестування

Типовий результат роботи програми:

```
Час виконання без кешування: 3.25 секунд
Час виконання з LRU-кешем: 0.78 секунд
Прискорення: 4.17x

Статистика кешу:
Кількість попадань в кеш: 3258
Кількість промахів кешу: 742
Відсоток попадань: 81.45%
```

## Технічні вимоги

- Python 3.6 або вище
- Стандартні бібліотеки: `random`, `time`, `collections.OrderedDict`

## Висновки

LRU-кеш є ефективним інструментом для оптимізації доступу до даних у випадках, коли запити до одних і тих же даних повторюються часто. Реалізація на основі `OrderedDict` в Python забезпечує простий і ефективний спосіб впровадження такого кешування в програми, що працюють з великими обсягами даних.

# Оптимізація обчислення чисел Фібоначчі: LRU-кеш vs. Splay Tree

## Опис

Цей проєкт реалізує та порівнює два методи обчислення чисел Фібоначчі:

1. **LRU Cache** – використання декоратора `@lru_cache` для кешування обчислених значень.
2. **Splay Tree** – використання структури даних `Splay Tree` для збереження вже обчислених значень.

Проєкт дозволяє оцінити ефективність кожного з підходів, вимірюючи середній час виконання для різних значень `n` та будуючи графік продуктивності.

---

## Встановлення та запуск

### **Вимоги**

Перед запуском переконайтеся, що у вас встановлені такі бібліотеки:

```sh
pip install matplotlib pandas numpy
```

### **Запуск програми**

Для виконання скрипта використовуйте команду:

```sh
python fibonacci.py
```

---

## Реалізація

### **Функція Фібоначчі з LRU-кешем**

```python
@lru_cache(maxsize=None)
def fibonacci_lru(n):
    if n < 2:
        return n
    return fibonacci_lru(n - 1) + fibonacci_lru(n - 2)
```

Декоратор `@lru_cache` автоматично кешує результати обчислень, що значно пришвидшує виконання повторних викликів.

### **Функція Фібоначчі з Splay Tree**

```python
def fibonacci_splay(n, tree):
    if n < 2:
        return n
    cached_result = tree.find(n)
    if cached_result is not None:
        return cached_result
    result = fibonacci_splay(n - 1, tree) + fibonacci_splay(n - 2, tree)
    tree.insert(n, result)
    return result
```

У цій реалізації `Splay Tree` використовується для зберігання та швидкого доступу до обчислених значень.

---

## Вимірювання продуктивності

Програма виконує вимірювання часу виконання для чисел Фібоначчі від `n = 0` до `n = 950` з кроком `50`. Для кожного `n` проводиться `5` повторів для підвищення точності результатів.

**Результати представлені у вигляді:**

1. **Графіка** – показує, який метод є швидшим.
2. **Таблиці** – виводиться в консоль для детального аналізу.

---

## Очікувані результати

- **LRU-кеш** зазвичай працює швидше, оскільки він кешує всі проміжні значення.
- **Splay Tree** також дозволяє зберігати та швидко знаходити вже обчислені значення, але має накладні витрати на балансування дерева.

---

## Автор

Автор: Eduard Schumacher Email: mijamoto911@gmail.com

Цей проєкт створений для демонстрації ефективності кешування у Python та використання `Splay Tree` для оптимізації обчислень.
